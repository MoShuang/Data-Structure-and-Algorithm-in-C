/*目前已学过的排序算法分为五大类：
1. 插入排序
    1.1 直接插入排序
    1.2 折半插入排序
    1.3 希尔排序
2. 交换排序
    2.1 冒泡排序
    2.2 双向冒泡排序
    2.3 快速排序
3. 比较排序
    3.1 简单比较排序
    3.2 堆排序
4. 其他
    4.1 归并排序
    4.2 基数排序
    4.3 桶排序
    4.4 外部排序
*/

//1.1直接插入排序
//1.主要思想：基于移动后插入操作，需要借助哨兵存储待插入元素
//2.具体步骤及代码实现：
void InsertSort(int A[], int n){
    //从第二个元素开始，向前寻找合适插入的位置;因此某待插入元素之前的元素必是有序的！
    for(int i = 2; i <= n; i++ ){
    //当之前恰好大于前一个元素，直接跳过不必再浪费时间比较(时间复杂度角度)
        if(A[i] < A[i-1])
            A[0] = A[i];
        for(int j = i-1; j > 0 && A[j] > A[0]; j—){
        //如果之前的元素存在更小的就向后移动（覆盖至待插入元素位置）
            //if(A[0] < A[j])此处语句功能可在循环判断内实现，故不必多余（代码简洁角度）
                A[j+1] = A[j];    
        }
        A[j+1] = A[0];//合适的插入位置;此处注意：如果相同j=j+1，但是循环跳出来了，表明相反，则应当插入的位置是j+1
    }
        
}
//3.分析： 时间复杂度为O(n2)
    
//2.3 快速排序
//1. 主要思想：基于交换，利用递归（递归工作栈先进后出的特性）分割了问题难度，且每次划分都能将枢轴元素放至最终位置
//2. 具体步骤和代码实现
void QuickSort(int A[], int low, int high){//递归的构成
//退出条件/继续递归条件
        //递归体
        if(low < high){//如果满足，继续划分找到枢轴元素并分隔子序列
            int pivotpos = Partition(A, low, high);
            QuickSort(A, low, pivotpos);
            QuickSort(A, pivotpos+1, high);
        }
       
        
}

int Partition(int A[], int low, int high){
    //使用两边逼近的思路，当一起遍历一次则最后的元素就是枢轴元素
    //采用严版教材，固定第一个元素为初始枢轴元素
    int pivot = A[low] 
    while(low < high){
        //右到左，找出较小值,覆盖枢轴元素位置
        while(low < high && A[high] > pivot) —high;//虽然外循环有限制条件，但是内循环在执行的时候不受约束，所以仍需要加上限制;
        //而且当元素相等时，仍然要移动（所以是不稳定算法），否则在接下来的划分操作中会导致算法失效
        A[low] = A[high];
        while(low < high && A[low] < pivot) ++low;//左到右找出较大值，覆盖右到左时空出的位置（数值重复位）
        A[high] = A[low]
    }
    //一趟结束，确定一个枢轴元素的最终位置，并将之返回作为划分子序列的依据
    A[low]  = pivot;
    return low;
}
